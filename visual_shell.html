<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Shell Pipeline</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Base form styles */
        .form-input, .form-select {
            @apply block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm;
        }
        /* Button styles */
        .btn {
            @apply inline-flex items-center justify-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium focus:outline-none focus:ring-2 focus:ring-offset-2;
        }
        .btn-blue {
            @apply text-white bg-blue-600 hover:bg-blue-700 focus:ring-blue-500;
        }
        .btn-gray {
            @apply text-slate-700 bg-slate-100 hover:bg-slate-200 focus:ring-slate-500;
        }
        .btn-outline {
            @apply text-xs px-2 py-1 bg-white border border-slate-300 text-slate-700 hover:bg-slate-50;
        }
        /* Custom styles for generated command box */
        #generated-command-box {
            background-color: #0f172a; /* slate-900 */
            color: #e2e8f0; /* slate-200 */
            font-family: monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        /* Style for pipeline steps */
        .step-card {
            background-color: #ffffff; /* White card */
            transition: all 0.3s ease-in-out;
            overflow: hidden;
        }
        /* Custom styles for select inputs to look consistent */
        .form-select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.5rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
    </style>
</head>
<body class="p-4 md:p-8 bg-slate-50">

    <!-- 
      - Top row (3-column) for data flow
      - Input -> Pipeline -> Output
    -->
    <div class="max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-3 gap-8 mb-8">

        <!-- Left Column: Input and Load -->
        <div class="space-y-6">

            <!-- Importer Section -->
            <div class="bg-white p-5 rounded-lg shadow">
                <h2 class="text-lg font-semibold text-slate-800 mb-3">Load Data</h2>
                <div class="space-y-4">
                    <p class="text-sm text-slate-600">Upload an Excel (.xlsx, .xls) or .csv file to begin.</p>
                    <input type="file" id="file-uploader" class="form-input text-sm text-slate-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100" accept=".xlsx, .xls, .csv">
                    <div id="sheet-selector-container" class="hidden space-y-2">
                        <label for="sheet-selector" class="block text-sm font-medium text-slate-700">Select Sheet:</label>
                        <div class="flex gap-2">
                            <select id="sheet-selector" class="form-select"></select>
                            <button id="load-sheet-btn" class="btn btn-blue whitespace-nowrap">Load</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Input Data Section -->
            <div class="bg-white p-5 rounded-lg shadow">
                <h2 class="text-lg font-semibold text-slate-800 mb-3">1. Input Data</h2>
                <textarea id="input-data" class="form-input font-mono text-sm" rows="18" placeholder="Paste your sample text, CSV, or log data here.
e.g.
id,name,score
1,alice,80
2,bob,90
3,charlie,85"></textarea>
            </div>
        </div>

        <!-- Middle Column: Pipeline Steps -->
        <div class="space-y-6">
            <!-- Container for steps, with contrasting background -->
            <div class="bg-slate-100 p-5 rounded-lg shadow h-full">
                <h2 class="text-lg font-semibold text-slate-800 mb-3">2. Pipeline Steps</h2>
                <div id="pipeline-steps" class="space-y-4 mb-4">
                    <!-- Steps will be dynamically added here -->
                </div>
                <div class="flex items-center gap-3">
                    <select id="add-step-select" class="form-select">
                        <option value="" disabled selected>Add a new step...</option>
                        <option value="cut">cut (Select columns)</option>
                        <option value="grep">grep (Filter lines by text)</option>
                        <option value="sort">sort (Sort lines)</option>
                        <option value="uniq">uniq (Find unique lines)</option>
                        <option value="head">head (Get first N lines)</option>
                        <option value="tail">tail (Get last N lines)</option>
                        <option value="tr">tr (Translate/Delete chars)</option>
                        <option value="wc">wc (Word/Line count)</option>
                        <option value="awk">awk (Advanced processing)</option>
                    </select>
                    <button id="add-step-btn" class="btn btn-blue whitespace-nowrap">Add Step</button>
                </div>
            </div>
        </div>

        <!-- Right Column: Live Preview -->
        <div class="space-y-6">
            <div class="bg-white p-5 rounded-lg shadow h-full">
                <h2 class="text-lg font-semibold text-slate-800 mb-3">3. Live Preview</h2>
                <p id="preview-error" class="text-sm text-red-600 mb-2 hidden"></p>
                <!-- Preview area height set to be scrollable -->
                <div id="live-preview" class="form-input bg-slate-50 font-mono text-sm h-96 overflow-auto" rows="18"></div>
            </div>
        </div>

    </div>

    <!-- 
      - Bottom row (2-column) for command generation
    -->
    <div class="max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-2 gap-8">
        
        <!-- Parse Command Section -->
        <div class="bg-white p-5 rounded-lg shadow">
            <h2 class="text-lg font-semibold text-slate-800 mb-3">Parse Shell Command</h2>
            <p class="text-sm text-slate-600 mb-2">Paste a command to see it in the pipeline.</p>
            <textarea id="parse-command-input" class="form-input font-mono text-sm mb-2" rows="5" placeholder="cat test.csv | cut -d',' -f2 | sort"></textarea>
            <div class="flex justify-end">
                <button id="parse-command-btn" class="btn btn-gray">Parse</button>
            </div>
        </div>

        <!-- Generated Command Section -->
        <div class="bg-white p-5 rounded-lg shadow">
            <div class="flex justify-between items-center mb-3">
                <h2 class="text-lg font-semibold text-slate-800">4. Generated Shell Command</h2>
                <button id="copy-command-btn" class="btn btn-gray whitespace-nowrap">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                    </svg>
                    Copy
                </button>
            </div>
            <div class="flex items-center justify-end mb-2">
                <input type="checkbox" id="format-command-check" class="h-4 w-4 text-blue-600 border-slate-300 rounded focus:ring-blue-500" checked>
                <label for="format-command-check" class="ml-2 block text-sm text-slate-700">Format for readability</label>
            </div>
            <div id="generated-command-box" class="form-input p-3 rounded-md h-36 overflow-auto">
                cat YOUR_FILE.csv
            </div>
        </div>

    </div>

    <!-- SheetJS Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <script>
        // State
        let pipelineSteps = [];

        // Element Selectors
        const inputDataEl = document.getElementById('input-data');
        const livePreviewEl = document.getElementById('live-preview');
        const pipelineStepsEl = document.getElementById('pipeline-steps');
        const addStepSelectEl = document.getElementById('add-step-select');
        const addStepBtnEl = document.getElementById('add-step-btn');
        const generatedCommandEl = document.getElementById('generated-command-box');
        const copyCommandBtnEl = document.getElementById('copy-command-btn');
        const parseCommandInputEl = document.getElementById('parse-command-input');
        const parseCommandBtnEl = document.getElementById('parse-command-btn');
        const formatCommandCheckEl = document.getElementById('format-command-check');
        const previewErrorEl = document.getElementById('preview-error');

        // File Uploader Elements
        const fileUploaderEl = document.getElementById('file-uploader');
        const sheetSelectorContainerEl = document.getElementById('sheet-selector-container');
        const sheetSelectorEl = document.getElementById('sheet-selector');
        const loadSheetBtnEl = document.getElementById('load-sheet-btn');
        let workbook = null;

        // --- Core Logic ---

        /**
         * Takes the input text and applies all pipeline steps sequentially.
         * @param {string} text - The initial input text.
         * @returns {string} - The final, processed text.
         */
        function processPipeline(text) {
            let currentText = text;
            let currentLines = currentText.split('\n');

            for (const step of pipelineSteps) {
                if (currentText.startsWith("Error: Preview not available")) {
                    return currentText;
                }
                
                try {
                    switch (step.type) {
                        case 'cut':
                            currentLines = currentLines.map(line => {
                                const delimiter = step.options.d === '\t' ? /\t/ : (step.options.d || ',');
                                const parts = line.split(delimiter);
                                // FIX: Use (step.options.f || '') to prevent crash if f is undefined
                                const fields = (step.options.f || '').split(',').map(Number);
                                return fields.map(f => parts[f - 1] || '').join(step.options.d || ',');
                            });
                            break;
                        case 'grep':
                            const searchTerm = step.options.v ? step.options.v : (step.options.pattern || '');
                            const isRegex = !step.options.F; // Not fixed string
                            const isCaseInsensitive = !!step.options.i;
                            let regexFlags = isCaseInsensitive ? 'i' : '';
                            
                            let regex;
                            if (isRegex) {
                                regex = new RegExp(searchTerm, regexFlags);
                            } else {
                                // Escape special regex chars for fixed string search
                                const escapedSearchTerm = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                                regex = new RegExp(escapedSearchTerm, regexFlags);
                            }
                            
                            currentLines = currentLines.filter(line => {
                                const match = regex.test(line);
                                return step.options.v ? !match : match; // Invert logic for -v
                            });
                            break;
                        case 'sort':
                            // Simple string sort
                            currentLines.sort();
                            if (step.options.r) {
                                currentLines.reverse();
                            }
                            break;
                        case 'uniq':
                            let newLines = [];
                            if (currentLines.length > 0) {
                                newLines.push(currentLines[0]);
                                for (let i = 1; i < currentLines.length; i++) {
                                    if (currentLines[i] !== currentLines[i - 1]) {
                                        newLines.push(currentLines[i]);
                                    }
                                }
                            }
                            currentLines = newLines;
                            break;
                        case 'head':
                            currentLines = currentLines.slice(0, Number(step.options.n || 10));
                            break;
                        case 'tail':
                            currentLines = currentLines.slice(-Number(step.options.n || 10));
                            break;
                        case 'tr':
                            const set1 = step.options.set1 || '';
                            const set2 = step.options.set2 || '';
                            
                            if (step.options.d) { // Delete
                                const regex = new RegExp(`[${set1.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}]`, 'g');
                                currentLines = currentLines.map(line => line.replace(regex, ''));
                            } else if (step.options.s) { // Squeeze
                                const regex = new RegExp(`([${set1.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}])\\1+`, 'g');
                                currentLines = currentLines.map(line => line.replace(regex, '$1'));
                            } else { // Translate
                                currentLines = currentLines.map(line => {
                                    let newLine = '';
                                    for (const char of line) {
                                        const index = set1.indexOf(char);
                                        if (index !== -1) {
                                            newLine += set2[index] || ''; // Use char from set2
                                        } else {
                                            newLine += char; // Keep original char
                                        }
                                    }
                                    return newLine;
                                });
                            }
                            break;
                        case 'wc':
                            const lineCount = currentLines.length;
                            const wordCount = currentLines.join(' ').split(/\s+/).filter(Boolean).length;
                            const charCount = currentText.length;
                            
                            let wcOutput = [];
                            if (step.options.l) wcOutput.push(lineCount);
                            if (step.options.w) wcOutput.push(wordCount);
                            if (step.options.c) wcOutput.push(charCount);
                            if (wcOutput.length === 0) {
                                wcOutput = [lineCount, wordCount, charCount];
                            }
                            currentLines = [wcOutput.join('\t')];
                            break;
                        case 'awk':
                            // Simplified awk preview for print
                            const awkProgram = step.options.program || '{ print $0 }';
                            const printMatch = awkProgram.match(/{ ?print (\$[0-9, ]+) ?}/);
                            
                            if (printMatch) {
                                const fields = printMatch[1].split(',').map(f => f.trim().substring(1));
                                const delimiter = step.options.F === '\t' ? /\t/ : (step.options.F || /\s+/);
                                currentLines = currentLines.map(line => {
                                    const parts = line.split(delimiter);
                                    return fields.map(f => parts[f - 1] || '').join(' ');
                                });
                            } else {
                                // For complex awk, preview isn't possible
                                return "Error: Preview not available for complex awk programs. Check the generated command.";
                            }
                            break;
                    }
                } catch (err) {
                    console.error("Error processing step:", step, err);
                    return `Error in step ${step.type}: ${err.message}`;
                }
                
                currentText = currentLines.join('\n');
            }

            return currentText;
        }

        /**
         * Updates the live preview and generated command.
         */
        function updateOutput() {
            try {
                // Update Live Preview
                const inputText = inputDataEl.value;
                const outputText = processPipeline(inputText);
                
                if (outputText.startsWith("Error:")) {
                    previewErrorEl.textContent = outputText;
                    previewErrorEl.classList.remove('hidden');
                    livePreviewEl.textContent = '';
                } else {
                    previewErrorEl.textContent = '';
                    previewErrorEl.classList.add('hidden');
                    livePreviewEl.textContent = outputText;
                }

                // Update Generated Command
                updateGeneratedCommand();

            } catch (err) {
                console.error("Error updating output:", err);
                previewErrorEl.textContent = `A critical error occurred: ${err.message}`;
                previewErrorEl.classList.remove('hidden');
            }
        }

        /**
         * Updates the generated shell command box based on format preference.
         */
        function updateGeneratedCommand() {
            const format = formatCommandCheckEl.checked;
            const joiner = format ? " | \\\n  " : " | ";
            
            const command = pipelineSteps.reduce((cmd, step) => {
                let stepCmd = '';
                switch (step.type) {
                    case 'cut':
                        const d = step.options.d === '\t' ? "$'\\t'" : `'${(step.options.d || ',')}'`;
                        stepCmd = `cut -d${d} -f'${(step.options.f || '')}'`;
                        break;
                    case 'grep':
                        const flags = [
                            step.options.i ? '-i' : '',
                            step.options.v ? '-v' : '',
                            step.options.F ? '-F' : '',
                        ].filter(Boolean).join(' ');
                        const pattern = step.options.v ? step.options.v : (step.options.pattern || '');
                        stepCmd = `grep ${flags} '${pattern}'`;
                        break;
                    case 'sort':
                        stepCmd = `sort ${step.options.r ? '-r' : ''}`;
                        break;
                    case 'uniq':
                        stepCmd = `uniq`;
                        break;
                    case 'head':
                        stepCmd = `head -n ${step.options.n || 10}`;
                        break;
                    case 'tail':
                        stepCmd = `tail -n ${step.options.n || 10}`;
                        break;
                    case 'tr':
                        const trFlags = [
                            step.options.d ? '-d' : '',
                            step.options.s ? '-s' : '',
                        ].filter(Boolean).join('');
                        stepCmd = `tr ${trFlags} '${step.options.set1 || ''}' '${step.options.set2 || ''}'`;
                        break;
                    case 'wc':
                        const wcFlags = [
                            step.options.l ? '-l' : '',
                            step.options.w ? '-w' : '',
                            step.options.c ? '-c' : '',
                        ].filter(Boolean).join(' ');
                        stepCmd = `wc ${wcFlags}`;
                        break;
                    case 'awk':
                        const f = step.options.F === '\t' ? "$'\\t'" : `'${(step.options.F || '')}'`;
                        const awkF = step.options.F ? `-F${f} ` : '';
                        stepCmd = `awk ${awkF}'${step.options.program || '{ print $0 }'}'`;
                        break;
                }
                return cmd + joiner + stepCmd;
            }, "cat YOUR_FILE.csv");

            generatedCommandEl.textContent = command;
        }

        /**
         * Renders all current pipeline steps to the DOM.
         */
        function renderPipelineSteps() {
            pipelineStepsEl.innerHTML = ''; // Clear existing steps
            pipelineSteps.forEach((step, index) => {
                const stepEl = document.createElement('div');
                stepEl.className = 'step-card border border-slate-200 p-4 rounded-lg shadow-sm';
                stepEl.setAttribute('data-id', step.id);
                stepEl.innerHTML = getStepHtml(step);
                pipelineStepsEl.appendChild(stepEl);
            });
        }

        /**
         * Returns the HTML for a single step card.
         * @param {object} step - The step object.
         * @returns {string} - The HTML string for the step card.
         */
        function getStepHtml(step) {
            const commonHeader = `
                <div class="flex justify-between items-center mb-3">
                    <h3 class="text-sm font-bold text-slate-500 uppercase tracking-wider">${step.type}</h3>
                    <button data-action="remove" class="text-slate-400 hover:text-red-500" title="Remove step">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                        </svg>
                    </button>
                </div>
            `;

            switch (step.type) {
                case 'cut':
                    return `
                        ${commonHeader}
                        <div class="grid grid-cols-2 gap-3">
                            <div>
                                <label for="cut_d_${step.id}" class="block text-sm font-medium text-slate-700">Delimiter (-d)</label>
                                <input type="text" name="d" id="cut_d_${step.id}" value="${step.options.d || ','}" class="form-input mt-1 text-sm">
                                <div class="flex flex-wrap gap-2 mt-2">
                                    <button class="btn-outline delimiter-btn" data-target="cut_d_${step.id}" data-value=",">CSV (,)</button>
                                    <button class="btn-outline delimiter-btn" data-target="cut_d_${step.id}" data-value="\t">TSV (Tab)</button>
                                    <button class="btn-outline delimiter-btn" data-target="cut_d_${step.id}" data-value=" ">Space</button>
                                </div>
                            </div>
                            <div>
                                <label for="cut_f_${step.id}" class="block text-sm font-medium text-slate-700">Fields (-f)</label>
                                <input type="text" name="f" id="cut_f_${step.id}" value="${step.options.f || ''}" class="form-input mt-1 text-sm" placeholder="e.g., 1,3">
                            </div>
                        </div>
                    `;
                case 'grep':
                    return `
                        ${commonHeader}
                        <div class="space-y-3">
                            <div>
                                <label for="grep_pattern_${step.id}" class="block text-sm font-medium text-slate-700">Pattern</label>
                                <input type="text" name="pattern" id="grep_pattern_${step.id}" value="${step.options.pattern || ''}" class="form-input mt-1" placeholder="Text or regex to find">
                            </div>
                            <div class="flex items-center gap-4">
                                <div class="flex items-center">
                                    <input type="checkbox" name="i" id="grep_i_${step.id}" ${step.options.i ? 'checked' : ''} class="h-4 w-4 text-blue-600 border-slate-300 rounded focus:ring-blue-500">
                                    <label for="grep_i_${step.id}" class="ml-2 block text-sm text-slate-700">Case-insensitive (-i)</label>
                                </div>
                                <div class="flex items-center">
                                    <input type="checkbox" name="v" id="grep_v_${step.id}" ${step.options.v ? 'checked' : ''} class="h-4 w-4 text-blue-600 border-slate-300 rounded focus:ring-blue-500">
                                    <label for="grep_v_${step.id}" class="ml-2 block text-sm text-slate-700">Invert match (-v)</label>
                                </div>
                                <div class="flex items-center">
                                    <input type="checkbox" name="F" id="grep_F_${step.id}" ${step.options.F ? 'checked' : ''} class="h-4 w-4 text-blue-600 border-slate-300 rounded focus:ring-blue-500">
                                    <label for="grep_F_${step.id}" class="ml-2 block text-sm text-slate-700">Fixed string (-F)</label>
                                </div>
                            </div>
                        </div>
                    `;
                case 'sort':
                    return `
                        ${commonHeader}
                        <div class="flex items-center">
                            <input type="checkbox" name="r" id="sort_r_${step.id}" ${step.options.r ? 'checked' : ''} class="h-4 w-4 text-blue-600 border-slate-300 rounded focus:ring-blue-500">
                            <label for="sort_r_${step.id}" class="ml-2 block text-sm text-slate-700">Reverse order (-r)</label>
                        </div>
                    `;
                case 'uniq':
                    return `${commonHeader}<p class="text-sm text-slate-600">Removes adjacent duplicate lines. (Use 'sort' first for a unique list)</p>`;
                case 'head':
                    return `
                        ${commonHeader}
                        <div>
                            <label for="head_n_${step.id}" class="block text-sm font-medium text-slate-700">Number of lines (-n)</label>
                            <input type="number" name="n" id="head_n_${step.id}" value="${step.options.n || 10}" class="form-input mt-1 w-24">
                        </div>
                    `;
                case 'tail':
                    return `
                        ${commonHeader}
                        <div>
                            <label for="tail_n_${step.id}" class="block text-sm font-medium text-slate-700">Number of lines (-n)</label>
                            <input type="number" name="n" id="tail_n_${step.id}" value="${step.options.n || 10}" class="form-input mt-1 w-24">
                        </div>
                    `;
                case 'tr':
                     return `
                        ${commonHeader}
                        <div class="space-y-3">
                            <div>
                                <label for="tr_set1_${step.id}" class="block text-sm font-medium text-slate-700">Characters 1 (SET1)</label>
                                <input type="text" name="set1" id="tr_set1_${step.id}" value="${step.options.set1 || ''}" class="form-input mt-1 text-sm font-mono" placeholder="e.g., abc">
                            </div>
                            <div>
                                <label for="tr_set2_${step.id}" class="block text-sm font-medium text-slate-700">Characters 2 (SET2)</label>
                                <input type="text" name="set2" id="tr_set2_${step.id}" value="${step.options.set2 || ''}" class="form-input mt-1 text-sm font-mono" placeholder="e.g., ABC">
                            </div>
                             <div class="flex items-center gap-4">
                                <div class="flex items-center">
                                    <input type="checkbox" name="d" id="tr_d_${step.id}" ${step.options.d ? 'checked' : ''} class="h-4 w-4 text-blue-600 border-slate-300 rounded focus:ring-blue-500">
                                    <label for="tr_d_${step.id}" class="ml-2 block text-sm text-slate-700">Delete (-d) SET1</label>
                                </div>
                                <div class="flex items-center">
                                    <input type="checkbox" name="s" id="tr_s_${step.id}" ${step.options.s ? 'checked' : ''} class="h-4 w-4 text-blue-600 border-slate-300 rounded focus:ring-blue-500">
                                    <label for="tr_s_${step.id}" class="ml-2 block text-sm text-slate-700">Squeeze (-s) SET1</text-sm>
                                </div>
                            </div>
                        </div>
                    `;
                case 'wc':
                     return `
                        ${commonHeader}
                        <p class="text-sm text-slate-600 mb-3">Counts lines, words, and/or characters. (Default is all three)</p>
                         <div class="flex items-center gap-4">
                            <div class="flex items-center">
                                <input type="checkbox" name="l" id="wc_l_${step.id}" ${step.options.l ? 'checked' : ''} class="h-4 w-4 text-blue-600 border-slate-300 rounded focus:ring-blue-500">
                                <label for="wc_l_${step.id}" class="ml-2 block text-sm text-slate-700">Lines (-l)</label>
                            </div>
                            <div class="flex items-center">
                                <input type="checkbox" name="w" id="wc_w_${step.id}" ${step.options.w ? 'checked' : ''} class="h-4 w-4 text-blue-600 border-slate-300 rounded focus:ring-blue-500">
                                <label for="wc_w_${step.id}" class="ml-2 block text-sm text-slate-700">Words (-w)</label>
                            </div>
                            <div class="flex items-center">
                                <input type="checkbox" name="c" id="wc_c_${step.id}" ${step.options.c ? 'checked' : ''} class="h-4 w-4 text-blue-600 border-slate-300 rounded focus:ring-blue-500">
                                <label for="wc_c_${step.id}" class="ml-2 block text-sm text-slate-700">Characters (-c)</label>
                            </div>
                        </div>
                    `;
                case 'awk':
                    const program = step.options.program || '{ print $0 }';
                    return `
                        ${commonHeader}
                        <div class="space-y-3">
                            <div>
                                <label for="awk_F_${step.id}" class="block text-sm font-medium text-slate-700">Field Separator (-F)</label>
                                <input type="text" name="F" id="awk_F_${step.id}" value="${step.options.F || ''}" class="form-input mt-1 text-sm" placeholder="Default: whitespace">
                                <div class="flex flex-wrap gap-2 mt-2">
                                    <button class="btn-outline delimiter-btn" data-target="awk_F_${step.id}" data-value=",">CSV (,)</button>
                                    <button class="btn-outline delimiter-btn" data-target="awk_F_${step.id}" data-value="\t">TSV (Tab)</button>
                                    <button class="btn-outline delimiter-btn" data-target="awk_F_${step.id}" data-value="">Whitespace</button>
                                </div>
                            </div>
                            <div>
                                <label for="awk_template_${step.id}" class="block text-sm font-medium text-slate-700">Program Templates</label>
                                <select id="awk_template_${step.id}" data-target="awk_program_${step.id}" class="form-select awk-template-select mt-1">
                                    <option value="" selected>Select a template...</option>
                                    <option value='{ print $1, $3 }'>Print Columns (e.g., 1 and 3)</option>
                                    <option value='$1 > 100 { print $0 }'>Filter Rows (e.g., col 1 > 100)</option>
                                    <option value='{ $3 = $1 + $2; print $0 }'>New Column (e.g., col 3 = col 1 + 2)</option>
                                    <option value='BEGIN { total=0 } { total+=$1 } END { print total }'>Sum a Column (e.g., col 1)</option>
                                    <option value='BEGIN { c=0; t=0 } { c++; t+=$1 } END { print t/c }'>Average a Column (e.g., col 1)</option>
                                </select>
                            </div>
                            <div>
                                <label for="awk_program_${step.id}" class="block text-sm font-medium text-slate-700">AWK Program</label>
                                <textarea name="program" id="awk_program_${step.id}" class="form-input mt-1 font-mono text-sm" rows="3">${program}</textarea>
                                <p class="mt-1 text-xs text-slate-500">Note: Live preview only supports basic 'print' commands. Generated command will be correct.</p>
                            </div>
                        </div>
                    `;
                default:
                    return `${commonHeader}<p>Unknown step type: ${step.type}</p>`;
            }
        }

        /**
         * Adds a new step to the pipeline.
         * @param {string} type - The type of step to add (e.g., 'cut', 'grep').
         */
        function addStep(type) {
            let defaultOptions = {};
            switch (type) {
                case 'cut':
                    defaultOptions = { d: ',', f: '1' };
                    break;
                case 'grep':
                    defaultOptions = { pattern: 'search', i: false, v: false, F: false };
                    break;
                case 'sort':
                    defaultOptions = { r: false };
                    break;
                case 'uniq':
                    defaultOptions = {};
                    break;
                case 'head':
                    defaultOptions = { n: '10' };
                    break;
                case 'tail':
                    defaultOptions = { n: '10' };
                    break;
                case 'tr':
                    defaultOptions = { set1: '', set2: '', d: false, s: false };
                    break;
                case 'wc':
                    defaultOptions = { l: false, w: false, c: false };
                    break;
                case 'awk':
                    defaultOptions = { F: '', program: '{ print $0 }' };
                    break;
            }
            pipelineSteps.push({
                id: Date.now() + Math.random(), // Unique ID
                type: type,
                options: defaultOptions
            });
            renderPipelineSteps();
            updateOutput();
        }

        /**
         * Removes a step from the pipeline by its ID.
         * @param {number} id - The unique ID of the step to remove.
         */
        function removeStep(id) {
            pipelineSteps = pipelineSteps.filter(step => step.id !== Number(id)); // Correctly compare number
            renderPipelineSteps();
            updateOutput();
        }

        /**
         * Updates the options for a step.
         * @param {number} id - The unique ID of the step.
         * @param {string} key - The option key to update.
         * @param {string|boolean} value - The new value for the option.
         */
        function updateStepOption(id, key, value) {
            const step = pipelineSteps.find(step => step.id === Number(id));
            if (step) {
                step.options[key] = value;
                updateOutput();
            }
        }

        // --- Event Handlers ---

        function handleStepClick(e) {
            // Event delegation for remove button
            if (e.target.closest('[data-action="remove"]')) {
                e.preventDefault();
                const stepEl = e.target.closest('.step-card');
                if (stepEl) {
                    removeStep(stepEl.dataset.id);
                }
            }

            // Event delegation for delimiter buttons
            if (e.target.classList.contains('delimiter-btn')) {
                e.preventDefault();
                const targetInput = document.getElementById(e.target.dataset.target);
                if (targetInput) {
                    targetInput.value = e.target.dataset.value;
                    // Manually trigger change event
                    targetInput.dispatchEvent(new Event('input', { bubbles: true }));
                }
            }

            // Event delegation for AWK template select
            if (e.target.classList.contains('awk-template-select')) {
                const program = e.target.value;
                if (program) {
                    const targetTextarea = document.getElementById(e.target.dataset.target);
                    if (targetTextarea) {
                        targetTextarea.value = program;
                        // Manually trigger change event
                        targetTextarea.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                }
            }
        }
        
        function handleStepChange(e) {
            // Event delegation for step option inputs
            const stepEl = e.target.closest('.step-card');
            if (!stepEl) return;

            const id = Number(stepEl.dataset.id);
            const key = e.target.name;
            const value = e.target.type === 'checkbox' ? e.target.checked : e.target.value;

            if (key) {
                updateStepOption(id, key, value);
            }
        }

        function handleAddStep() {
            const selectedType = addStepSelectEl.value;
            if (selectedType) {
                addStep(selectedType);
                addStepSelectEl.value = ''; // Reset dropdown
            }
        }

        function handleCopyCommand() {
            const command = pipelineSteps.reduce((cmd, step) => {
                // This logic must be identical to updateGeneratedCommand
                let stepCmd = '';
                 switch (step.type) {
                    case 'cut':
                        const d = step.options.d === '\t' ? "$'\\t'" : `'${(step.options.d || ',')}'`;
                        stepCmd = `cut -d${d} -f'${(step.options.f || '')}'`;
                        break;
                    case 'grep':
                        const flags = [
                            step.options.i ? '-i' : '',
                            step.options.v ? '-v' : '',
                            step.options.F ? '-F' : '',
                        ].filter(Boolean).join(' ');
                        const pattern = step.options.v ? step.options.v : (step.options.pattern || '');
                        stepCmd = `grep ${flags} '${pattern}'`;
                        break;
                    case 'sort':
                        stepCmd = `sort ${step.options.r ? '-r' : ''}`;
                        break;
                    case 'uniq':
                        stepCmd = `uniq`;
                        break;
                    case 'head':
                        stepCmd = `head -n ${step.options.n || 10}`;
                        break;
                    case 'tail':
                        stepCmd = `tail -n ${step.options.n || 10}`;
                        break;
                    case 'tr':
                        const trFlags = [
                            step.options.d ? '-d' : '',
                            step.options.s ? '-s' : '',
                        ].filter(Boolean).join('');
                        stepCmd = `tr ${trFlags} '${step.options.set1 || ''}' '${step.options.set2 || ''}'`;
                        break;
                    case 'wc':
                        const wcFlags = [
                            step.options.l ? '-l' : '',
                            step.options.w ? '-w' : '',
                            step.options.c ? '-c' : '',
                        ].filter(Boolean).join(' ');
                        stepCmd = `wc ${wcFlags}`;
                        break;
                    case 'awk':
                        const f = step.options.F === '\t' ? "$'\\t'" : `'${(step.options.F || '')}'`;
                        const awkF = step.options.F ? `-F${f} ` : '';
                        stepCmd = `awk ${awkF}'${step.options.program || '{ print $0 }'}'`;
                        break;
                }
                return cmd + " | " + stepCmd;
            }, "cat YOUR_FILE.csv");
            
            // Use execCommand for broader compatibility in sandboxed environments
            const textarea = document.createElement('textarea');
            textarea.value = command;
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                copyCommandBtnEl.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" /></svg> Copied!';
                setTimeout(() => {
                    copyCommandBtnEl.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg> Copy';
                }, 2000);
            } catch (err) {
                console.error('Failed to copy: ', err);
            }
            document.body.removeChild(textarea);
        }

        // --- Parser ---
        
        function handleParseCommand() {
            const commandString = parseCommandInputEl.value;
            try {
                const newSteps = parseCommandString(commandString);
                pipelineSteps = newSteps; // Replace current pipeline
                renderPipelineSteps();
                updateOutput();
                previewErrorEl.textContent = '';
                previewErrorEl.classList.add('hidden');
            } catch (err) {
                console.error("Failed to parse command:", err);
                previewErrorEl.textContent = `Parse Error: ${err.message}`;
                previewErrorEl.classList.remove('hidden');
            }
        }
        
        /**
         * Parses a shell command string into pipeline steps.
         * @param {string} commandString - The shell command.
         * @returns {Array<object>} - An array of step objects.
         */
        function parseCommandString(commandString) {
            // Sanitize: remove line continuations and newlines
            const singleLineCommand = commandString
                .replace(/\\\n\s*/g, ' ') // Remove \ at end of line
                .replace(/\n/g, ' ')     // Remove other newlines
                .trim();
            
            const parts = singleLineCommand.split('|').map(s => s.trim());
            // We ignore the first part (e.g., "cat YOUR_FILE.csv")
            const commandParts = parts.slice(1);
            
            return commandParts.map((part, index) => {
                const [cmd, ...args] = part.split(' ').filter(Boolean);
                const step = {
                    id: Date.now() + Math.random(), // Generate a unique ID
                    type: cmd,
                    options: {}
                };
                
                try {
                    parseSingleCommand(step, args);
                } catch(e) {
                    throw new Error(`Error parsing '${part}': ${e.message}`);
                }
                return step;
            });
        }
        
        /**
         * Helper to parse arguments for a single command.
         * Modifies the step.options object in place.
         * FIX: This is now more robust to prevent crashes.
         */
        function parseSingleCommand(step, args) {
            // Define known boolean flags (ones that don't take a value)
            const boolFlags = {
                sort: ['r'],
                grep: ['i', 'v', 'F'],
                uniq: [],
                tr: ['d', 's'],
                wc: ['l', 'w', 'c']
            };
            
            let i = 0;
            while (i < args.length) {
                const arg = args[i];
                
                // --- Handle Quoted/Positional Arguments ---
                // e.g., awk '{...}' or grep 'pattern'
                if (!arg.startsWith('-')) {
                    const value = arg.replace(/['"]/g, ''); // Naive unquote
                    if (step.type === 'grep' && !step.options.pattern) {
                        step.options.pattern = value;
                    } else if (step.type === 'awk' && arg.startsWith("'") && arg.endsWith("'")) {
                        step.options.program = arg.slice(1, -1);
                    }
                    i++;
                    continue;
                }
                
                // --- Handle Flags ---
                const flag = arg.substring(1);
                
                // Check if it's a known boolean flag for this command
                const isBoolFlag = (boolFlags[step.type] || []).includes(flag);
                
                if (isBoolFlag) {
                    step.options[flag] = true;
                    i++;
                } else {
                    // It's a flag that expects a value, e.g., -f 1 or -n 10
                    // Check if next argument is the value
                    if (i + 1 < args.length && !args[i + 1].startsWith('-')) {
                        let value = args[i + 1].replace(/['"$]/g, ''); // Naive unquote
                        if (value === '\\t') value = '\t'; // Handle tab
                        step.options[flag] = value;
                        i += 2; // Consumed flag and value
                    } else {
                        // Flag is missing its value, e.g., "cut -f | ..."
                        // Do *not* set it to true. Just skip it.
                        i++;
                    }
                }
            }
            
            // Post-processing for grep (pattern might be in a weird place)
            if (step.type === 'grep') {
                // This handles "grep -v 'pattern'" where 'pattern' was assigned to 'v'
                const flagsToReCheck = ['v', 'i', 'F'];
                flagsToReCheck.forEach(flag => {
                     if (step.options[flag] && typeof step.options[flag] === 'string') {
                         if (!step.options.pattern) {
                            step.options.pattern = step.options[flag];
                         }
                        step.options[flag] = true; // Set it back to a boolean
                    }
                });
            }
        }
        
        // --- Excel/File Importer ---
        
        function handleFileLoad(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();

            // Check for CSV, simple text read
            if (file.name.endsWith('.csv')) {
                reader.onload = (e) => {
                    inputDataEl.value = e.target.result;
                    updateOutput();
                };
                reader.readAsText(file);
                // Reset sheet selector
                workbook = null;
                sheetSelectorContainerEl.classList.add('hidden');
                return;
            }

            // Handle Excel files
            reader.onload = (e) => {
                const data = new Uint8Array(e.target.result);
                try {
                    workbook = XLSX.read(data, {type: 'array'});
                    
                    // Populate sheet selector
                    sheetSelectorEl.innerHTML = '';
                    workbook.SheetNames.forEach(sheetName => {
                        const option = document.createElement('option');
                        option.value = sheetName;
                        option.textContent = sheetName;
                        sheetSelectorEl.appendChild(option);
                    });
                    
                    sheetSelectorContainerEl.classList.remove('hidden');
                    // Automatically load the first sheet
                    loadSheet();

                } catch (err) {
                    console.error("Error reading workbook:", err);
                    // Use a more user-friendly error display
                    previewErrorEl.textContent = "Error reading Excel file. Is the file corrupted?";
                    previewErrorEl.classList.remove('hidden');
                }
            };
            reader.readAsArrayBuffer(file);
        }
        
        function loadSheet() {
            if (!workbook) return;
            
            const sheetName = sheetSelectorEl.value;
            const sheet = workbook.Sheets[sheetName];
            if (sheet) {
                // Convert sheet to CSV
                const csvData = XLSX.utils.sheet_to_csv(sheet);
                inputDataEl.value = csvData;
                updateOutput();
            }
        }

        // --- Event Listeners ---
        inputDataEl.addEventListener('input', updateOutput);
        addStepBtnEl.addEventListener('click', handleAddStep);
        pipelineStepsEl.addEventListener('click', handleStepClick);
        pipelineStepsEl.addEventListener('input', handleStepChange);
        copyCommandBtnEl.addEventListener('click', handleCopyCommand);
        parseCommandBtnEl.addEventListener('click', handleParseCommand);
        formatCommandCheckEl.addEventListener('change', updateGeneratedCommand);

        // File Uploader Listeners
        fileUploaderEl.addEventListener('change', handleFileLoad);
        loadSheetBtnEl.addEventListener('click', loadSheet);
        
        // Initial call
        updateOutput();

    </script>
</body>
</html>